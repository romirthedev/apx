<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Cluely Overlay</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: transparent;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            -webkit-app-region: no-drag;
        }
        
        .overlay-container {
            background: rgba(40, 40, 40, 0.95);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 0;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            -webkit-app-region: drag;
        }
        
        .input-container {
            flex: 0 0 auto;
            display: flex;
            align-items: center;
            padding: 20px;
            height: 80px;
            box-sizing: border-box;
            -webkit-app-region: no-drag;
        }
        
        .icon {
            font-size: 24px;
            margin-right: 15px;
            color: #007acc;
        }
        
        .command-input {
            flex: 1;
            background: transparent;
            border: none;
            outline: none;
            color: #ffffff;
            font-size: 16px;
            font-weight: 400;
        }
        
        .command-input::placeholder {
            color: #888888;
        }
        
        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4caf50;
            margin-right: 15px;
            animation: pulse 2s infinite;
        }
        
        .status-indicator.thinking {
            background: #ff9800;
            animation: thinking 1s infinite;
        }
        
        .status-indicator.error {
            background: #f44336;
            animation: none;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        @keyframes thinking {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        .result-container {
            flex: 1;
            background: transparent;
            padding: 0 20px 20px 20px;
            max-height: 500px;
            overflow-y: auto;
            display: none;
            width: 100%;
            box-sizing: border-box;
            position: relative;
            z-index: 1000;
            -webkit-app-region: no-drag;
        }
        
        .result-container.show {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        .result-content {
            background: rgba(45, 45, 45, 0.95) !important;
            border-radius: 8px;
            padding: 15px;
            border-left: 3px solid #007acc;
            margin-bottom: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            width: 100%;
            box-sizing: border-box;
            min-height: 40px;
            position: relative;
        }
        
        .result-text {
            color: #ffffff;
            font-size: 14px;
            line-height: 1.6;
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
        }
        
        .result-success {
            border-left-color: #4caf50;
            background: rgba(76, 175, 80, 0.1);
        }
        
        .result-error {
            border-left-color: #f44336;
            background: rgba(244, 67, 54, 0.1);
        }
        
        .result-thinking {
            border-left-color: #ff9800;
            background: rgba(255, 152, 0, 0.1);
        }
        
        .ai-response {
            border-left-color: #9c27b0;
            background: rgba(156, 39, 176, 0.1);
        }
        
        .ai-response::before {
            content: "ðŸ¤– AI Response";
            display: block;
            font-size: 12px;
            color: #9c27b0;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .typing-indicator {
            display: inline-block;
        }
        
        .typing-indicator::after {
            content: '...';
            animation: dots 1.5s infinite;
        }
        
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }
        
        .action-status {
            background: rgba(0, 122, 204, 0.1);
            border: 1px solid rgba(0, 122, 204, 0.3);
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 10px;
            color: #007acc;
            font-size: 13px;
            font-weight: 500;
        }
        
        .action-status.working {
            animation: pulse 2s infinite;
        }
    </style>
</head>
<body>
    <div class="overlay-container">
        <div class="input-container">
            <div class="icon">ðŸ§ </div>
            <input 
                type="text" 
                class="command-input" 
                id="commandInput"
                placeholder="Ask me anything..."
                autocomplete="off"
                spellcheck="false"
            >
            <div class="status-indicator" id="statusIndicator"></div>
        </div>
        
        <div class="result-container" id="resultContainer">
            <div class="action-status" id="actionStatus" style="display: none;"></div>
            <div class="result-content" id="resultContent">
                <p class="result-text" id="resultText"></p>
            </div>
        </div>
    </div>

    <script>
        const { ipcRenderer } = require('electron');
        
        const commandInput = document.getElementById('commandInput');
        const statusIndicator = document.getElementById('statusIndicator');
        const resultContainer = document.getElementById('resultContainer');
        const resultContent = document.getElementById('resultContent');
        const resultText = document.getElementById('resultText');
        const actionStatus = document.getElementById('actionStatus');
        
        let isProcessing = false;
        let currentResponse = '';
        let typingTimeout;
        
        // Focus input when overlay is shown
        ipcRenderer.on('focus-input', () => {
            commandInput.focus();
            commandInput.select();
        });
        
        // Add click handlers to keep overlay open when interacting
        document.addEventListener('click', (e) => {
            console.log('ðŸ–±ï¸ Overlay clicked - preventing auto-hide');
            // Clear auto-hide timeout when user interacts
            if (window.autoHideTimeout) {
                clearTimeout(window.autoHideTimeout);
                window.autoHideTimeout = null;
            }
        });
        
        // Also prevent hiding when hovering over results
        document.addEventListener('mouseenter', () => {
            if (resultContainer.classList.contains('show')) {
                console.log('ðŸ–±ï¸ Mouse entered overlay with results - preventing auto-hide');
                if (window.autoHideTimeout) {
                    clearTimeout(window.autoHideTimeout);
                    window.autoHideTimeout = null;
                }
            }
        });
        
        // Handle command submission
        commandInput.addEventListener('keydown', async (event) => {
            if (event.key === 'Enter' && !isProcessing) {
                const command = commandInput.value.trim();
                if (command) {
                    // Test command for debugging
                    if (command === 'test') {
                        console.log('ðŸ§ª Running test command...');
                        console.log('ðŸ“ Resizing overlay for test...');
                        resizeOverlay(300);
                        
                        // Wait for resize
                        await new Promise(resolve => setTimeout(resolve, 200));
                        
                        console.log('ðŸ“ Showing test result...');
                        showResult('ðŸŽ‰ TEST SUCCESSFUL!\n\nIf you can see this message, the overlay response system is working correctly.\n\nThe issue might be with:\n- Backend connection\n- Response processing\n- Auto-hide timing\n\nTry asking: "help" or "what time is it"', 'success', false);
                        
                        // Don't auto-hide for test
                        setTimeout(() => {
                            console.log('ðŸ§ª Test complete - overlay will stay open');
                        }, 1000);
                        
                        return;
                    }
                    
                    await processCommand(command);
                }
            } else if (event.key === 'Escape') {
                console.log('âŒ¨ï¸ Escape key pressed');
                hideOverlay();
            }
        });
        
        async function processCommand(command) {
            if (isProcessing) return;
            
            console.log('ðŸš€ Processing command:', command);
            isProcessing = true;
            setStatus('thinking');
            showActionStatus('ðŸ§  Analyzing your request...');
            
            // FIRST: Expand overlay to make room for results
            console.log('ðŸ“ Resizing overlay to 400px...');
            resizeOverlay(400);
            
            // Wait a moment for resize to take effect
            await new Promise(resolve => setTimeout(resolve, 100));
            
            try {
                // Show thinking indicator
                console.log('ðŸ’­ Showing thinking indicator...');
                showResult('Thinking<span class="typing-indicator"></span>', 'thinking');
                
                console.log('ðŸ“¡ Sending command to backend...');
                const response = await ipcRenderer.invoke('send-command', command);
                console.log('ðŸ“¨ Backend response received:', response);
                
                if (response.success) {
                    console.log('âœ… Processing successful response...');
                    setStatus('success');
                    hideActionStatus();
                    
                    // Always show the result, whether AI or not
                    const resultText = response.result || 'Command completed successfully';
                    const isAiResponse = response.is_ai_response || false;
                    
                    console.log('ðŸ“‹ Response details:', {
                        resultLength: resultText.length,
                        isAiResponse,
                        method: response.metadata?.method,
                        success: response.success
                    });
                    
                    // Make sure overlay is big enough
                    const neededHeight = Math.max(400, Math.min(600, 200 + resultText.length * 0.5));
                    console.log(`ðŸ“ Expanding overlay to ${neededHeight}px for response...`);
                    resizeOverlay(neededHeight);
                    
                    // Wait for resize then show result
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Show AI response with typing effect for longer responses
                    if (isAiResponse && resultText.length > 50) {
                        console.log('ðŸ¤– Showing AI response with typing effect...');
                        showActionStatus('ðŸ¤– AI is responding...');
                        await typeResponse(resultText, 'success', true);
                        hideActionStatus();
                    } else {
                        console.log('ðŸ“ Showing regular response...');
                        showResult(resultText, 'success', isAiResponse);
                    }
                    
                    // Show metadata if available
                    if (response.metadata && response.metadata.method) {
                        const methodText = `Method: ${response.metadata.method}`;
                        setTimeout(() => {
                            showActionStatus(`â„¹ï¸ ${methodText}`);
                        }, 1000);
                    }
                    
                    // Clear input after successful command
                    commandInput.value = '';
                    
                    // Don't auto-hide - let user read the response
                    console.log('â° Setting auto-hide timer...');
                    const hideDelay = isAiResponse ? 20000 : 15000; // Even longer delays
                    console.log(`â° Will auto-hide in ${hideDelay}ms`);
                    
                    // Clear any existing timeout
                    if (window.autoHideTimeout) {
                        clearTimeout(window.autoHideTimeout);
                    }
                    
                    window.autoHideTimeout = setTimeout(() => {
                        console.log('â° Auto-hide timer triggered');
                        hideOverlay();
                    }, hideDelay);
                } else {
                    setStatus('error');
                    hideActionStatus();
                    const errorMsg = response.error || response.result || 'Command failed';
                    showResult(`âŒ ${errorMsg}`, 'error');
                    
                    // Show more details for debugging
                    if (response.error && response.result) {
                        setTimeout(() => {
                            showActionStatus(`Details: ${response.result}`);
                        }, 1000);
                    }
                }
            } catch (error) {
                console.error('Command processing error:', error);
                setStatus('error');
                hideActionStatus();
                showResult(`âš ï¸ Connection Error: ${error.message}\n\nPlease check if the backend service is running.`, 'error');
                showActionStatus('ðŸ’¡ Try: npm run backend');
            } finally {
                isProcessing = false;
                
                // Reset status after 3 seconds
                setTimeout(() => {
                    setStatus('ready');
                }, 3000);
            }
        }
        
        function setStatus(status) {
            statusIndicator.className = 'status-indicator';
            if (status === 'thinking') {
                statusIndicator.classList.add('thinking');
            } else if (status === 'error') {
                statusIndicator.classList.add('error');
            }
        }
        
        function showResult(text, type = '', isAiResponse = false) {
            console.log('ðŸ” showResult called with:', { 
                textLength: text.length, 
                textPreview: text.substring(0, 50), 
                type, 
                isAiResponse 
            });
            
            // Notify main process that we're showing a response
            ipcRenderer.send('overlay-showing-response', true);
            
            // Force clear any existing content
            resultText.innerHTML = '';
            resultContent.className = 'result-content';
            
            // Set the content
            resultText.innerHTML = text;
            
            // Apply styling
            if (isAiResponse) {
                resultContent.classList.add('ai-response');
                console.log('âœ… Applied AI response styling');
            } else if (type === 'success') {
                resultContent.classList.add('result-success');
                console.log('âœ… Applied success styling');
            } else if (type === 'error') {
                resultContent.classList.add('result-error');
                console.log('âœ… Applied error styling');
            } else if (type === 'thinking') {
                resultContent.classList.add('result-thinking');
                console.log('âœ… Applied thinking styling');
            }
            
            // Force display with multiple approaches
            resultContainer.style.display = 'block';
            resultContainer.style.visibility = 'visible';
            resultContainer.style.opacity = '1';
            resultContainer.style.height = 'auto';
            resultContainer.style.minHeight = '60px';
            resultContainer.classList.add('show');
            
            // Calculate needed height based on content
            setTimeout(() => {
                const contentHeight = document.body.scrollHeight;
                const contentWidth = document.body.scrollWidth;
                const minHeight = 150;
                const maxHeight = 600;
                const neededHeight = Math.max(minHeight, Math.min(maxHeight, contentHeight + 40));
                
                console.log('ðŸ“ Content sizing:', {
                    contentHeight,
                    contentWidth,
                    neededHeight,
                    currentHeight: resultContainer.offsetHeight
                });
                
                // Resize overlay to fit content
                resizeOverlay(neededHeight);
            }, 50);
            
            // Log final state
            console.log('ðŸ“Š Result container final state:', {
                display: resultContainer.style.display,
                visibility: resultContainer.style.visibility,
                opacity: resultContainer.style.opacity,
                classList: resultContainer.classList.toString(),
                innerHTML: resultContainer.innerHTML.length > 0
            });
            
            // Scroll into view if needed
            resultContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
        
        async function typeResponse(text, type = '', isAiResponse = false) {
            currentResponse = '';
            const words = text.split(' ');
            
            // Show initial message with typing indicator
            showResult('', type, isAiResponse);
            
            for (let i = 0; i < words.length; i++) {
                currentResponse += words[i] + ' ';
                showResult(currentResponse + '<span class="typing-indicator"></span>', type, isAiResponse);
                await new Promise(resolve => setTimeout(resolve, 30)); // Faster typing
            }
            
            // Remove typing indicator and show final result
            showResult(currentResponse.trim(), type, isAiResponse);
        }
        
        function showActionStatus(text) {
            actionStatus.textContent = text;
            actionStatus.className = 'action-status working';
            actionStatus.style.display = 'block';
        }
        
        function hideActionStatus() {
            actionStatus.style.display = 'none';
        }
        
        function resizeOverlay(height) {
            ipcRenderer.send('resize-overlay', height);
        }
        
        function hideResult() {
            console.log('ðŸ‘» hideResult called - was visible:', resultContainer.style.display !== 'none');
            resultContainer.style.display = 'none';
            resultContainer.classList.remove('show');
            
            // Notify main process that response is no longer showing
            ipcRenderer.send('overlay-showing-response', false);
        }
        
        function hideOverlay() {
            console.log('ðŸšª hideOverlay called - stack trace:', new Error().stack);
            
            // Clear any auto-hide timeout
            if (window.autoHideTimeout) {
                clearTimeout(window.autoHideTimeout);
                window.autoHideTimeout = null;
            }
            
            hideResult();
            hideActionStatus();
            commandInput.value = '';
            resizeOverlay(80);
            // Don't immediately close, let user see the result
            setTimeout(() => {
                console.log('ðŸšª Actually closing overlay window...');
                window.close();
            }, 500);
        }
        
        // Initialize
        setStatus('ready');
        
        // Focus input when loaded
        window.addEventListener('load', () => {
            commandInput.focus();
            
            // Debug: Make sure overlay is visible
            console.log('ðŸ–¼ï¸ Overlay loaded. Container style:', {
                background: window.getComputedStyle(document.querySelector('.overlay-container')).background,
                display: window.getComputedStyle(document.querySelector('.overlay-container')).display,
                opacity: window.getComputedStyle(document.querySelector('.overlay-container')).opacity
            });
            
            // Add test function for debugging
            window.testResult = function() {
                console.log('Testing result display...');
                resizeOverlay(300);
                showResult('This is a test response to check if results are displaying correctly!', 'success', false);
            };
            
            // Force a quick visual test
            setTimeout(() => {
                console.log('ðŸ§ª Overlay should be visible now');
                const container = document.querySelector('.overlay-container');
                console.log('ðŸ“¦ Container element:', container);
                console.log('ðŸ“¦ Container visible:', container && container.offsetHeight > 0);
            }, 1000);
        });
    </script>
</body>
</html>
