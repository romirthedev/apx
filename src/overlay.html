<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Cluely Overlay</title>
    
    <!-- Markdown rendering library -->
    <script src="https://cdn.jsdelivr.net/npm/marked@9.1.6/marked.min.js"></script>
    
    <!-- KaTeX for LaTeX rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
    
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            -webkit-app-region: no-drag;
        }
        
        .overlay-container {
            background: rgba(25, 25, 25, 0.2);
            backdrop-filter: blur(12px);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            padding: 0;
            height: calc(100vh - 100px);
            width: 700px;
            display: flex;
            flex-direction: column;
            -webkit-app-region: drag;
            margin: 100px auto 20px auto;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .input-container {
            flex: 0 0 auto;
            display: flex;
            align-items: center;
            padding: 20px;
            height: 80px;
            box-sizing: border-box;
            -webkit-app-region: no-drag;
        }
        
        .icon {
            font-size: 24px;
            margin-right: 15px;
            color: #007acc;
        }
        
        .command-input {
            flex: 1;
            background: transparent;
            border: none;
            outline: none;
            color: #ffffff;
            font-size: 16px;
            font-weight: 400;
        }
        
        .command-input::placeholder {
            color: #888888;
        }
        
        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4caf50;
            margin-right: 15px;
            animation: pulse 2s infinite;
        }
        
        .status-indicator.thinking {
            background: #ff9800;
            animation: thinking 1s infinite;
        }
        
        .status-indicator.error {
            background: #f44336;
            animation: none;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        @keyframes thinking {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        .result-container {
            flex: 1;
            background: transparent;
            padding: 0 20px 20px 20px;
            max-height: 500px;
            overflow-y: auto;
            display: none;
            width: 100%;
            box-sizing: border-box;
            position: relative;
            z-index: 1000;
            -webkit-app-region: no-drag;
        }
        
        .result-container.show {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        .result-content {
            background: rgba(45, 45, 45, 0.95) !important;
            border-radius: 8px;
            padding: 15px;
            border-left: 3px solid #007acc;
            margin-bottom: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            width: 100%;
            box-sizing: border-box;
            min-height: 40px;
            position: relative;
        }
        
        .result-text {
            color: #ffffff;
            font-size: 14px;
            line-height: 1.6;
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
        }
        
        .result-success {
            border-left-color: #4caf50;
            background: rgba(76, 175, 80, 0.1);
        }
        
        .result-error {
            border-left-color: #f44336;
            background: rgba(244, 67, 54, 0.1);
        }
        
        .result-thinking {
            border-left-color: #ff9800;
            background: rgba(255, 152, 0, 0.1);
        }
        
        .ai-response {
            border-left-color: #9c27b0;
            background: rgba(156, 39, 176, 0.1);
        }
        
        .ai-response::before {
            content: "ðŸ¤– AI Response";
            display: block;
            font-size: 12px;
            color: #9c27b0;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .typing-indicator {
            display: inline-block;
        }
        
        .typing-indicator::after {
            content: '...';
            animation: dots 1.5s infinite;
        }
        
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }
        
        .action-status {
            background: rgba(0, 122, 204, 0.1);
            border: 1px solid rgba(0, 122, 204, 0.3);
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 10px;
            color: #007acc;
            font-size: 13px;
            font-weight: 500;
        }
        
        .action-status.working {
            animation: pulse 2s infinite;
        }
        
        /* KaTeX and LaTeX styling */
        .katex {
            font-size: 1.1em;
        }
        
        .katex-display {
            margin: 1em 0;
            text-align: center;
        }
        
        .latex-error {
            color: #ff6b6b;
            background-color: rgba(255, 107, 107, 0.1);
            padding: 2px 4px;
            border-radius: 3px;
            font-family: monospace;
        }
        
        .latex-fallback {
            color: #666;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="overlay-container">
        <div class="input-container">
            <div class="icon">ðŸ§ </div>
            <input 
                type="text" 
                class="command-input" 
                id="commandInput"
                placeholder="Ask me anything..."
                autocomplete="off"
                spellcheck="false"
            >
            <div class="status-indicator" id="statusIndicator"></div>
        </div>
        
        <div class="result-container" id="resultContainer">
            <div class="action-status" id="actionStatus" style="display: none;"></div>
            <div class="result-content" id="resultContent">
                <p class="result-text" id="resultText"></p>
            </div>
        </div>
    </div>

    <script>
        const { ipcRenderer } = require('electron');
        
        const commandInput = document.getElementById('commandInput');
        const statusIndicator = document.getElementById('statusIndicator');
        const resultContainer = document.getElementById('resultContainer');
        const resultContent = document.getElementById('resultContent');
        const resultText = document.getElementById('resultText');
        const actionStatus = document.getElementById('actionStatus');
        
        let isProcessing = false;
        let currentResponse = '';
        let typingTimeout;
        
        // Focus input when overlay is shown
        ipcRenderer.on('focus-input', () => {
            commandInput.focus();
            commandInput.select();
        });
        
        // Add click handlers to keep overlay open when interacting
        document.addEventListener('click', (e) => {
            console.log('ðŸ–±ï¸ Overlay clicked - preventing auto-hide');
            // Clear auto-hide timeout when user interacts
            if (window.autoHideTimeout) {
                clearTimeout(window.autoHideTimeout);
                window.autoHideTimeout = null;
            }
        });
        
        // Also prevent hiding when hovering over results
        document.addEventListener('mouseenter', () => {
            if (resultContainer.classList.contains('show')) {
                console.log('ðŸ–±ï¸ Mouse entered overlay with results - preventing auto-hide');
                if (window.autoHideTimeout) {
                    clearTimeout(window.autoHideTimeout);
                    window.autoHideTimeout = null;
                }
            }
        });
        
        // Handle command submission
        commandInput.addEventListener('keydown', async (event) => {
            if (event.key === 'Enter' && !isProcessing) {
                const command = commandInput.value.trim();
                if (command) {
                    // Test command for debugging
                    if (command === 'test') {
                        console.log('ðŸ§ª Running test command...');
                        console.log('ðŸ“ Resizing overlay for test...');
                        resizeOverlay(300);
                        
                        // Wait for resize
                        await new Promise(resolve => setTimeout(resolve, 200));
                        
                        console.log('ðŸ“ Showing test result...');
                        showResult('ðŸŽ‰ TEST SUCCESSFUL!\n\nIf you can see this message, the overlay response system is working correctly.\n\nThe issue might be with:\n- Backend connection\n- Response processing\n- Auto-hide timing\n\nTry asking: "help" or "what time is it"', 'success', false);
                        
                        // Don't auto-hide for test
                        setTimeout(() => {
                            console.log('ðŸ§ª Test complete - overlay will stay open');
                        }, 1000);
                        
                        return;
                    }
                    
                    await processCommand(command);
                }
            } else if (event.key === 'Escape') {
                console.log('âŒ¨ï¸ Escape key pressed');
                hideOverlay();
            }
        });

        // Handle Command+Arrow keys for moving the overlay window
        document.addEventListener('keydown', (event) => {
            // Check if Command key (Meta key on Mac) is pressed with arrow keys
            if (event.metaKey && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
                event.preventDefault();
                
                // Map arrow keys to direction strings
                let direction;
                switch (event.key) {
                    case 'ArrowUp':
                        direction = 'up';
                        break;
                    case 'ArrowDown':
                        direction = 'down';
                        break;
                    case 'ArrowLeft':
                        direction = 'left';
                        break;
                    case 'ArrowRight':
                        direction = 'right';
                        break;
                }
                
                // Send IPC message to move the entire window
                ipcRenderer.send('move-overlay-window', direction);
                console.log(`ðŸŽ¯ Moving overlay window: ${direction}`);
            }
        });
        
        async function processCommand(command) {
            if (isProcessing) return;
            
            console.log('ðŸš€ Processing command:', command);
            isProcessing = true;
            setStatus('thinking');
            showActionStatus('ðŸ§  Analyzing your request...');
            
            // FIRST: Expand overlay to make room for results
            console.log('ðŸ“ Resizing overlay to 400px...');
            resizeOverlay(400);
            
            // Wait a moment for resize to take effect
            await new Promise(resolve => setTimeout(resolve, 100));
            
            try {
                // Show thinking indicator
                console.log('ðŸ’­ Showing thinking indicator...');
                showResult('Thinking<span class="typing-indicator"></span>', 'thinking');
                
                console.log('ðŸ“¡ Sending command to backend...');
                const response = await ipcRenderer.invoke('send-command', command);
                console.log('ðŸ“¨ Backend response received:', response);
                
                if (response.success) {
                    console.log('âœ… Processing successful response...');
                    setStatus('success');
                    hideActionStatus();
                    
                    // Always show the result, whether AI or not
                    const resultText = response.result || 'Command completed successfully';
                    const isAiResponse = response.is_ai_response || false;
                    
                    console.log('ðŸ“‹ Response details:', {
                        resultLength: resultText.length,
                        isAiResponse,
                        method: response.metadata?.method,
                        success: response.success
                    });
                    
                    // Make sure overlay is big enough
                    const neededHeight = Math.max(400, Math.min(600, 200 + resultText.length * 0.5));
                    console.log(`ðŸ“ Expanding overlay to ${neededHeight}px for response...`);
                    resizeOverlay(neededHeight);
                    
                    // Wait for resize then show result
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Show AI response with typing effect for longer responses
                    if (isAiResponse && resultText.length > 50) {
                        console.log('ðŸ¤– Showing AI response with typing effect...');
                        showActionStatus('ðŸ¤– AI is responding...');
                        await typeResponse(resultText, 'success', true);
                        hideActionStatus();
                    } else {
                        console.log('ðŸ“ Showing regular response...');
                        showResult(resultText, 'success', isAiResponse);
                    }
                    
                    // Show metadata if available
                    if (response.metadata && response.metadata.method) {
                        const methodText = `Method: ${response.metadata.method}`;
                        setTimeout(() => {
                            showActionStatus(`â„¹ï¸ ${methodText}`);
                        }, 1000);
                    }
                    
                    // Clear input after successful command
                    commandInput.value = '';
                    
                    // Overlay will remain open until manually closed by user
                } else {
                    setStatus('error');
                    hideActionStatus();
                    const errorMsg = response.error || response.result || 'Command failed';
                    showResult(`âŒ ${errorMsg}`, 'error');
                    
                    // Show more details for debugging
                    if (response.error && response.result) {
                        setTimeout(() => {
                            showActionStatus(`Details: ${response.result}`);
                        }, 1000);
                    }
                }
            } catch (error) {
                console.error('Command processing error:', error);
                setStatus('error');
                hideActionStatus();
                showResult(`âš ï¸ Connection Error: ${error.message}\n\nPlease check if the backend service is running.`, 'error');
                showActionStatus('ðŸ’¡ Try: npm run backend');
            } finally {
                isProcessing = false;
                
                // Reset status after 3 seconds
                setTimeout(() => {
                    setStatus('ready');
                }, 3000);
            }
        }
        
        function setStatus(status) {
            statusIndicator.className = 'status-indicator';
            if (status === 'thinking') {
                statusIndicator.classList.add('thinking');
            } else if (status === 'error') {
                statusIndicator.classList.add('error');
            }
        }
        
        function showResult(text, type = '', isAiResponse = false) {
            console.log('ðŸ” showResult called with:', { 
                textLength: text.length, 
                textPreview: text.substring(0, 50), 
                type, 
                isAiResponse 
            });
            
            // Notify main process that we're showing a response
            ipcRenderer.send('overlay-showing-response', true);
            
            // Force clear any existing content
            resultText.innerHTML = '';
            resultContent.className = 'result-content';
            
            // Set the content with LaTeX processing
            resultText.innerHTML = processMarkdownAndLatex(text);
            
            // Apply styling
            if (isAiResponse) {
                resultContent.classList.add('ai-response');
                console.log('âœ… Applied AI response styling');
            } else if (type === 'success') {
                resultContent.classList.add('result-success');
                console.log('âœ… Applied success styling');
            } else if (type === 'error') {
                resultContent.classList.add('result-error');
                console.log('âœ… Applied error styling');
            } else if (type === 'thinking') {
                resultContent.classList.add('result-thinking');
                console.log('âœ… Applied thinking styling');
            }
            
            // Force display with multiple approaches
            resultContainer.style.display = 'block';
            resultContainer.style.visibility = 'visible';
            resultContainer.style.opacity = '1';
            resultContainer.style.height = 'auto';
            resultContainer.style.minHeight = '60px';
            resultContainer.classList.add('show');
            
            // Calculate needed height based on content
            setTimeout(() => {
                const contentHeight = document.body.scrollHeight;
                const contentWidth = document.body.scrollWidth;
                const minHeight = 150;
                const maxHeight = 600;
                const neededHeight = Math.max(minHeight, Math.min(maxHeight, contentHeight + 40));
                
                console.log('ðŸ“ Content sizing:', {
                    contentHeight,
                    contentWidth,
                    neededHeight,
                    currentHeight: resultContainer.offsetHeight
                });
                
                // Resize overlay to fit content
                resizeOverlay(neededHeight);
            }, 50);
            
            // Log final state
            console.log('ðŸ“Š Result container final state:', {
                display: resultContainer.style.display,
                visibility: resultContainer.style.visibility,
                opacity: resultContainer.style.opacity,
                classList: resultContainer.classList.toString(),
                innerHTML: resultContainer.innerHTML.length > 0
            });
            
            // Scroll into view if needed
            resultContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
        
        async function typeResponse(text, type = '', isAiResponse = false) {
            currentResponse = '';
            const words = text.split(' ');
            
            // Show initial message with typing indicator
            showResult('', type, isAiResponse);
            
            for (let i = 0; i < words.length; i++) {
                currentResponse += words[i] + ' ';
                showResult(currentResponse + '<span class="typing-indicator"></span>', type, isAiResponse);
                await new Promise(resolve => setTimeout(resolve, 30)); // Faster typing
            }
            
            // Remove typing indicator and show final result
            showResult(currentResponse.trim(), type, isAiResponse);
        }
        
        function processMarkdownAndLatex(text) {
          try {
            console.log('ðŸ” Processing text for LaTeX:', text.substring(0, 200) + (text.length > 200 ? '...' : ''));
            // First, protect LaTeX equations by temporarily replacing them
            const latexBlocks = [];
            const latexInline = [];
            
            // Extract display math ($$...$$ or \[...\]) - improved regex
            let processedText = text.replace(/\$\$([\s\S]*?)\$\$|\\\[([\s\S]*?)\\\]/g, (match, eq1, eq2) => {
              const equation = (eq1 || eq2).trim();
              if (equation) {
                console.log('ðŸ“ Found display math equation:', equation);
                const index = latexBlocks.length;
                latexBlocks.push(equation);
                return `LATEX_BLOCK_${index}`;
              }
              return match;
            });
            
            // Extract inline math ($...$) - improved to avoid conflicts with display math
            processedText = processedText.replace(/\$([^$\n]+?)\$/g, (match, equation) => {
              // Skip if this is part of display math (already processed)
              if (match.includes('LATEX_BLOCK_')) {
                return match;
              }
              const trimmedEq = equation.trim();
              if (trimmedEq) {
                console.log('ðŸ“ Found inline math equation:', trimmedEq);
                const index = latexInline.length;
                latexInline.push(trimmedEq);
                return `LATEX_INLINE_${index}`;
              }
              return match;
            });
            
            // Configure marked with custom renderer for code blocks
            const renderer = new marked.Renderer();
            renderer.code = function(code, language) {
              // Enhanced language detection if not specified
              if (!language) {
                if (code.includes('def ') || code.includes('import ') || code.includes('print(') || code.includes('__init__')) {
                  language = 'python';
                } else if (code.includes('function ') || code.includes('const ') || code.includes('console.log') || code.includes('=>')) {
                  language = 'javascript';
                } else if (code.includes('#include') || code.includes('int main') || code.includes('std::') || code.includes('cout')) {
                  language = 'cpp';
                } else if (code.includes('public class') || code.includes('System.out') || code.includes('public static')) {
                  language = 'java';
                } else if (code.includes('SELECT') || code.includes('FROM') || code.includes('WHERE')) {
                  language = 'sql';
                } else if (code.includes('<html>') || code.includes('<div>') || code.includes('<!DOCTYPE')) {
                  language = 'html';
                }
              }
              
              return `<pre><code class="language-${language || 'text'}">${code}</code></pre>`;
            };
            
            // Process markdown
            let finalContent = marked.parse(processedText, { renderer });
            
            // Restore LaTeX equations and render them
            if (typeof katex !== 'undefined') {
              // Restore and render display math
              latexBlocks.forEach((equation, index) => {
                try {
                  const rendered = katex.renderToString(equation, {
                    displayMode: true,
                    throwOnError: false,
                    strict: 'ignore',
                    trust: true,
                    fleqn: false,
                    macros: {
                      "\\RR": "\\mathbb{R}",
                      "\\NN": "\\mathbb{N}",
                      "\\ZZ": "\\mathbb{Z}",
                      "\\QQ": "\\mathbb{Q}",
                      "\\CC": "\\mathbb{C}",
                      "\\FF": "\\mathbb{F}",
                      "\\PP": "\\mathbb{P}",
                      "\\HH": "\\mathbb{H}",
                      "\\implies": "\\Rightarrow",
                      "\\iff": "\\Leftrightarrow",
                      "\\eps": "\\epsilon",
                      "\\veps": "\\varepsilon"
                    }
                  });
                  finalContent = finalContent.replace(`LATEX_BLOCK_${index}`, rendered);
                } catch (e) {
                  console.error('LaTeX rendering error for block equation:', equation, 'Error:', e);
                  finalContent = finalContent.replace(`LATEX_BLOCK_${index}`, `<span class="latex-error">$$${equation}$$</span>`);
                }
              });
              
              // Restore and render inline math
              latexInline.forEach((equation, index) => {
                try {
                  const rendered = katex.renderToString(equation, {
                    displayMode: false,
                    throwOnError: false,
                    strict: 'ignore',
                    trust: true,
                    macros: {
                      "\\RR": "\\mathbb{R}",
                      "\\NN": "\\mathbb{N}",
                      "\\ZZ": "\\mathbb{Z}",
                      "\\QQ": "\\mathbb{Q}",
                      "\\CC": "\\mathbb{C}",
                      "\\FF": "\\mathbb{F}",
                      "\\PP": "\\mathbb{P}",
                      "\\HH": "\\mathbb{H}",
                      "\\implies": "\\Rightarrow",
                      "\\iff": "\\Leftrightarrow",
                      "\\eps": "\\epsilon",
                      "\\veps": "\\varepsilon"
                    }
                  });
                  finalContent = finalContent.replace(`LATEX_INLINE_${index}`, rendered);
                } catch (e) {
                  console.error('LaTeX rendering error for inline equation:', equation, 'Error:', e);
                  finalContent = finalContent.replace(`LATEX_INLINE_${index}`, `<span class="latex-error">$${equation}$</span>`);
                }
              });
            } else {
              // Fallback if KaTeX is not loaded
              latexBlocks.forEach((equation, index) => {
                finalContent = finalContent.replace(`LATEX_BLOCK_${index}`, `<span class="latex-fallback">$$${equation}$$</span>`);
              });
              latexInline.forEach((equation, index) => {
                finalContent = finalContent.replace(`LATEX_INLINE_${index}`, `<span class="latex-fallback">$${equation}$</span>`);
              });
            }
            
            // Apply syntax highlighting to any remaining code blocks
            setTimeout(() => {
              if (typeof Prism !== 'undefined') {
                Prism.highlightAll();
              }
            }, 100);
            
            return finalContent;
            
          } catch (error) {
            console.error('Markdown/LaTeX processing error:', error);
            return text.replace(/\n/g, '<br>');
          }
        }
        
        function showActionStatus(text) {
            actionStatus.textContent = text;
            actionStatus.className = 'action-status working';
            actionStatus.style.display = 'block';
        }
        
        function hideActionStatus() {
            actionStatus.style.display = 'none';
        }
        
        function resizeOverlay(height) {
            ipcRenderer.send('resize-overlay', height);
        }
        
        function hideResult() {
            console.log('ðŸ‘» hideResult called - was visible:', resultContainer.style.display !== 'none');
            resultContainer.style.display = 'none';
            resultContainer.classList.remove('show');
            
            // Notify main process that response is no longer showing
            ipcRenderer.send('overlay-showing-response', false);
        }
        
        function hideOverlay() {
            console.log('ðŸšª hideOverlay called - stack trace:', new Error().stack);
            
            // Clear any auto-hide timeout
            if (window.autoHideTimeout) {
                clearTimeout(window.autoHideTimeout);
                window.autoHideTimeout = null;
            }
            
            hideResult();
            hideActionStatus();
            commandInput.value = '';
            resizeOverlay(80);
            // Don't immediately close, let user see the result
            setTimeout(() => {
                console.log('ðŸšª Actually closing overlay window...');
                window.close();
            }, 500);
        }
        
        // Listen for context refresh events
        ipcRenderer.on('context-refreshed', () => {
            console.log('ðŸ”„ Context refreshed - overlay notified');
            // You can add visual feedback here if needed
            // For example, briefly show a notification or update UI
        });
        
        // Initialize
        setStatus('ready');
        
        // Focus input when loaded
        window.addEventListener('load', () => {
            commandInput.focus();
            
            // Debug: Make sure overlay is visible
            console.log('ðŸ–¼ï¸ Overlay loaded. Container style:', {
                background: window.getComputedStyle(document.querySelector('.overlay-container')).background,
                display: window.getComputedStyle(document.querySelector('.overlay-container')).display,
                opacity: window.getComputedStyle(document.querySelector('.overlay-container')).opacity
            });
            
            // Add test function for debugging
            window.testResult = function() {
                console.log('Testing result display...');
                resizeOverlay(300);
                showResult('This is a test response to check if results are displaying correctly!', 'success', false);
            };
            
            // Force a quick visual test
            setTimeout(() => {
                console.log('ðŸ§ª Overlay should be visible now');
                const container = document.querySelector('.overlay-container');
                console.log('ðŸ“¦ Container element:', container);
                console.log('ðŸ“¦ Container visible:', container && container.offsetHeight > 0);
            }, 1000);
        });
    </script>
</body>
</html>
